<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Maze Game | Abhay Vashist</title>
<meta name=keywords content="pygame,python,game"><meta name=description content="Maze Generation and Solving Game using Pygame"><meta name=author content="Abhay Vashist"><link rel=canonical href=https://avashist1998.github.io/posts/maze_game/><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://avashist1998.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://avashist1998.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://avashist1998.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://avashist1998.github.io/apple-touch-icon.png><link rel=mask-icon href=https://avashist1998.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Maze Game"><meta property="og:description" content="Maze Generation and Solving Game using Pygame"><meta property="og:type" content="article"><meta property="og:url" content="https://avashist1998.github.io/posts/maze_game/"><meta property="og:image" content="https://images.nightcafe.studio/jobs/JIODE2KiPFTlX8mPB4Ry/JIODE2KiPFTlX8mPB4Ry--1--r2fxo_2x.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-10T13:47:03-06:00"><meta property="article:modified_time" content="2023-02-10T13:47:03-06:00"><meta property="og:site_name" content="PersonalSite"><meta property="og:see_also" content="https://avashist1998.github.io/posts/events_app/"><meta property="og:see_also" content="https://avashist1998.github.io/posts/number_recognition/"><meta property="og:see_also" content="https://avashist1998.github.io/posts/sorting_visualization/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://images.nightcafe.studio/jobs/JIODE2KiPFTlX8mPB4Ry/JIODE2KiPFTlX8mPB4Ry--1--r2fxo_2x.jpg"><meta name=twitter:title content="Maze Game"><meta name=twitter:description content="Maze Generation and Solving Game using Pygame"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://avashist1998.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Maze Game","item":"https://avashist1998.github.io/posts/maze_game/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Maze Game","name":"Maze Game","description":"Maze Generation and Solving Game using Pygame","keywords":["pygame","python","game"],"articleBody":"I build maze solving game using Pygame: Check it out\nWhat Technologies I used Python (Programming Language) Pytest (Unit testing) Pygame (Visualization \u0026 Keyboard Events) Pygbag (Python to wasm tool for Web Distribution) Github Pages (Hosting) Github Action (CI pipeline) Github (Version Tracking) How did I build It Codebase Github Repo\nDesign The game is built using the MVC (Model-View-Controller) architecture and is based on Wesley Werner’s repository. I highly recommend checking out his repository for better understanding.\nImportant Files main.py: Entry point for the game application src : Containing all of the python source code logger.py: Defines the logger of the game event.py: Defines different type of event in the game environment model.py: Defines the Game Engine of game view.py: Defines the Visual of the game maze_game: Contains the logic and maze generation code. maze_visualization: Contains helper function for game visuals test: Contains the test written for the game Maze Generation I used the Randomized Prim’s algorithm for generating the maze, which is a popular choice for maze generation. I followed Orestis Zekai’s article on maze generation using Python, which was helpful for the basic setup. However, I had some difficulty following the final parts of the article, so I implemented my own version. You can find the final version of my implementation in this file on Github.\nMaze Board Value Enum The MazeGameObject enum improves the readability of the code and creates a layer of abstraction between the values on the game board and the maze generation code.\nclass MazeGameObject(Enum): PATH = 0 WALL = 1 GOAL = 2 EMPTY = -1 PLAYER_TILE = 7 VISITED_TILE = 3 Maze Generation Code breakdown Initialize the maze with Empty object values (Exactly same as Zekai) def init_maze(height, width): maze = [] for _ in range(height): maze_row = [MazeGameObject.EMPTY.value for _ in range(width)] maze.append(maze_row) return maze Pick a start position by randomly selecting a location in the maze that does not lie on the edge. (Exactly same as Zekai) from random import random def get_start_pos(row, col): start_row, start_col = int(random() * (row-2))+1, int(random() * (col-2))+1 return start_row, start_col Function fills the empty cells with wall value (Exactly same as Zekai) def fill_walls(maze) for i, _ in enumerate(maze): for j in range(len(maze[0])): if maze[i][j] == MazeGameObject.EMPTY.value: maze[i][j] = MazeGameObject.WALL.value To determine the number of paths surrounding a given cell in the maze, we examine the adjacent cells using if statements. If the cells are within the grid’s boundaries and have the same value as the path, the s_cell_count is incremented. def get_surrounding_cell_count(cell, maze): s_cell_count = 0 if (cell[0] \u003e 0 and maze[cell[0] - 1][cell[1]] == MazeGameObject.PATH.value): s_cell_count += 1 if (cell[0] \u003c len(maze) - 1 and maze[cell[0] + 1][cell[1]] == MazeGameObject.PATH.value): s_cell_count += 1 if (cell[1] \u003e 0 and maze[cell[0]][cell[1] - 1] == MazeGameObject.PATH.value): s_cell_count += 1 if (cell[1] \u003c len(maze[0]) - 1 and maze[cell[0]][cell[1] + 1] == MazeGameObject.PATH.value): s_cell_count += 1 return s_cell_count To create entry and exit points for the maze after it’s generated, we break the top and bottom walls of the maze into paths that are adjacent to existing paths. This creates a long and winding path that leads from the entrance to the exit of the maze. This step is important because it ensures that there is a clear path from the entrance to the exit, and that the maze is solvable. def create_entry_exit(maze): row, col = len(maze), len(maze[0]) start_point, exit_point = (0, 0), (row - 1, col - 1) # Set entrance and exit for i in range(col): if maze[1][i] == MazeGameObject.PATH.value: maze[0][i] = MazeGameObject.PLAYER_TILE.value start_point = (0, i) break for i in range(col - 1, 0, -1): if maze[row - 2][i] == MazeGameObject.PATH.value: maze[row - 1][i] = MazeGameObject.GOAL.value exit_point = (row - 1, i) break return start_point, exit_point, maze Generation the maze\nThe first step in generating the maze is to initialize the board using the init_maze function.\nmaze = init_maze(n_row, n_col) We need to determine the starting position of the maze, which we achieve using the get_start_pos function. This function ensures that the starting position is always a path cell and returns its coordinates. We then set the start_pos variable to these coordinates.\nstart_pos = get_start_pos(maze) maze[start_pos[0]][start_pos[1]] = MazeGameObject.PATH.value We assign the surrounding cells to the start_pos to the value of a WALL. Then we add the defined walls the our queue, in my case a set named wall_list\nmaze[start_pos[0] - 1][start_pos[1]] = MazeGameObject.WALL.value maze[start_pos[0]][start_pos[1] - 1] = MazeGameObject.WALL.value maze[start_pos[0]][start_pos[1] + 1] = MazeGameObject.WALL.value maze[start_pos[0] + 1][start_pos[1]] = MazeGameObject.WALL.value wall_list = set() wall_list.add((start_pos[0] - 1, start_pos[1])) wall_list.add((start_pos[0], start_pos[1] - 1)) wall_list.add((start_pos[0], start_pos[1] + 1)) wall_list.add((start_pos[0] + 1, start_pos[1])) After the initialization steps, the maze generation algorithm repeats the following steps until all the walls in the maze have been processed:\nPick a random wall from the wall_list. Count the number of surrounding cells of the wall that are paths using the get_surrounding_cell_count function. If the count is greater than 1, remove the wall from the wall_list since it has been processed. If the count is 1, we process the wall and remove the wall from the wall_list. We continue this process until the wall_list is empty. After all the cells are processed, we fill the remaining cells with walls using the fill_walls function.\nFinally, we create an entry and exit in the maze using the create_entry_exit function.\nfrom random import choices while wall_list: rand_wall = choices(list(wall_list), k=1)[0] s_cell_count = get_surrounding_cell_count(rand_wall, maze) if s_cell_count \u003c 2: ### Wall Processing block wall_list.remove(rand_wall) fill_walls(maze) entry_point, exit_point, maze = create_entry_exit(maze) return entry_point, exit_point, maze The “Row case” and “Col case” refer to the two possibilities for which direction the wall being processed is oriented: either horizontally (a “row”) or vertically (a “column”).\nFor each of these cases, there are two sub-cases, based on whether the wall is at the edge of the grid or not. If the wall being processed is not at the edge of the grid, the code checks the cells on either side of the wall to see if one of them is a path and the other empty (i.e. possible connected). If so, the wall is removed from the wall list, meaning it is no longer available to be broken down. If the wall being processed is at the edge of the grid, the code only checks the cells on the side that is not at the edge. This is because the cells on the other side are already known to be walls, since they lie outside the bounds of the grid. Row Cases: Case 1: Case 2: Path Empty | | Wall Wall | | Empty Path Col Cases: Case 1: Path - Wall - Empty Case 2: Empty - Wall - Path if (rand_wall[0] \u003e 0 and rand_wall[0] + 1 \u003c n_row): # row case if (maze[rand_wall[0] - 1][rand_wall[1]] == MazeGameObject.WALL.value and maze[rand_wall[0] + 1][rand_wall[1]] == MazeGameObject.PATH.value): # Case 2 maze[rand_wall[0]][rand_wall[1]] = MazeGameObject.PATH.value maze[rand_wall[0] - 1][rand_wall[1]] = MazeGameObject.WALL.value maze[rand_wall[0]][rand_wall[1] - 1] = MazeGameObject.WALL.value maze[rand_wall[0]][rand_wall[1] + 1] = MazeGameObject.WALL.value wall_list.add((rand_wall[0] - 1, rand_wall[1])) wall_list.add((rand_wall[0], rand_wall[1] + 1)) wall_list.add((rand_wall[0], rand_wall[1] - 1)) if (maze[rand_wall[0] + 1][rand_wall[1]] == MazeGameObject.WALL.value and maze[rand_wall[0] + 1][rand_wall[1]] == MazeGameObject.PATH.value): # Case 1 # Similar logic as case 2 block if (rand_wall[1] \u003e 0 and rand_wall[1] + 1 \u003c n_col): ### similar logic as above row cases Maze Visualization Visualizing the maze requires two main functions, draw_maze and draw_tile which are defined here. The function communicates using two data classes called Tile and ScreenSize. This approach makes the visualization independent of the value of the tile and treats each tile equally. In other words, the function doesn’t need to know what the tile represents in terms of the maze structure, it only needs to know the dimensions of the tile and the screen size to properly display it on the screen. This separation of concerns makes the code easier to maintain and modify in the future, as changes to the tile value won’t affect the visualization code.\nfrom dataclasses import dataclass @dataclass class Tile: \"\"\"Maze tile data object definition.\"\"\" tile_color: Color border_color: Color tile_space: ScreenSize @dataclass class ScreenSize: \"\"\"Screen size dataclass\"\"\" width: int height: int top_left_x: int top_left_y: int In the draw_maze function, the first step is to calculate the total dimensions and define the screen size of the maze in pixels. The maze will occupy all of the space on the screen except for 50 pixels on the left and right sides, and 75 pixels on the top and 25 pixels on the bottom. Once we have the maze size in pixels, we need to compute the size of individual tiles using integer division.\nNext, we iterate through the grid and set the appropriate tile color based on the grid cell value. We calculate the tile’s top-left coordinates by multiplying the index with the tile size and adding the maze board’s top-left coordinates. Then, we call the draw_tile function to render the tile on the screen.\nboard = maze.get_board() # maze generated previously row, col = len(board), len(board[0]) maze_board_top, maze_board_left = 75, 50 maze_screen_width = self.screen_width - 100 maze_screen_height = self.screen_height - 100 tile_width, tile_height = maze_screen_width // col, maze_screen_height // row for i in range(row): for j in range(col): if board[i][j] == MazeGameObject.WALL.value: tile_color = WALL_COLOR elif board[i][j] == MazeGameObject.GOAL.value: tile_color = GOAL_COLOR elif board[i][j] == MazeGameObject.VISITED_TILE.value: tile_color = VISITED_COLOR elif board[i][j] == MazeGameObject.PLAYER_TILE.value: tile_color = PLAYER_COLOR else: tile_color = PATH_COLOR tile_space = ScreenSize(tile_width, tile_height, maze_board_left + j * tile_width, maze_board_top + i * tile_height) tile = Tile(tile_color, TILE_BORDER_COLOR, tile_space) self.draw_tile(tile) def draw_tile(self, tile): boarder_thickness = int(tile.tile_space.width * 0.1) pygame.draw.rect( self.screen, tile.tile_color, pygame.Rect(tile.tile_space.top_left_x, tile.tile_space.top_left_y, tile.tile_space.width, tile.tile_space.height), 0) if boarder_thickness \u003e 0: pygame.draw.rect( self.screen, tile.border_color, pygame.Rect(tile.tile_space.top_left_x, tile.tile_space.top_left_y, tile.tile_space.width, tile.tile_space.height), boarder_thickness) Maze Animation Final Thoughts This project to build a maze game using pygame was a valuable experience for me, and I highly recommend it as a way to learn pygame and prototype game ideas. Pygame provides a great environment for individuals to develop simple and small games, and the process can be very enjoyable. I hope you found my explanation of the project informative and enjoyable.\n","wordCount":"1667","inLanguage":"en","image":"https://images.nightcafe.studio/jobs/JIODE2KiPFTlX8mPB4Ry/JIODE2KiPFTlX8mPB4Ry--1--r2fxo_2x.jpg","datePublished":"2023-02-10T13:47:03-06:00","dateModified":"2023-02-10T13:47:03-06:00","author":{"@type":"Person","name":"Abhay Vashist"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://avashist1998.github.io/posts/maze_game/"},"publisher":{"@type":"Organization","name":"Abhay Vashist","logo":{"@type":"ImageObject","url":"https://avashist1998.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://avashist1998.github.io accesskey=h title="Abhay Vashist (Alt + H)">Abhay Vashist</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://avashist1998.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://avashist1998.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://avashist1998.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://avashist1998.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Maze Game</h1><div class=post-description>Maze Generation and Solving Game using Pygame</div><div class=post-meta><span title='2023-02-10 13:47:03 -0600 -0600'>February 10, 2023</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Abhay Vashist</div></header><figure class=entry-cover><img loading=eager src=https://images.nightcafe.studio/jobs/JIODE2KiPFTlX8mPB4Ry/JIODE2KiPFTlX8mPB4Ry--1--r2fxo_2x.jpg alt></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-technologies-i-used aria-label="What Technologies I used">What Technologies I used</a></li><li><a href=#how-did-i-build-it aria-label="How did I build It">How did I build It</a><ul><li><a href=#codebase aria-label=Codebase>Codebase</a></li><li><a href=#design aria-label=Design>Design</a></li><li><a href=#maze-generation aria-label="Maze Generation">Maze Generation</a><ul><li><a href=#maze-board-value-enum aria-label="Maze Board Value Enum">Maze Board Value Enum</a></li></ul></li><li><a href=#maze-generation-code-breakdown aria-label="Maze Generation Code breakdown">Maze Generation Code breakdown</a></li><li><a href=#maze-visualization aria-label="Maze Visualization">Maze Visualization</a></li><li><a href=#maze-animation aria-label="Maze Animation">Maze Animation</a></li><li><a href=#final-thoughts aria-label="Final Thoughts">Final Thoughts</a></li></ul></li></ul></div></details></div><div class=post-content><p>I build maze solving game using <code>Pygame</code>: <a href=https://avashist1998.github.io/maze_game/>Check it out</a></p><h2 id=what-technologies-i-used>What Technologies I used<a hidden class=anchor aria-hidden=true href=#what-technologies-i-used>#</a></h2><ul><li>Python (Programming Language)</li><li>Pytest (Unit testing)</li><li>Pygame (Visualization & Keyboard Events)</li><li>Pygbag (Python to wasm tool for Web Distribution)</li><li>Github Pages (Hosting)</li><li>Github Action (CI pipeline)</li><li>Github (Version Tracking)</li></ul><h2 id=how-did-i-build-it>How did I build It<a hidden class=anchor aria-hidden=true href=#how-did-i-build-it>#</a></h2><h3 id=codebase>Codebase<a hidden class=anchor aria-hidden=true href=#codebase>#</a></h3><p><a href=https://github.com/avashist1998/maze_game>Github Repo</a></p><h3 id=design>Design<a hidden class=anchor aria-hidden=true href=#design>#</a></h3><p>The game is built using the MVC (Model-View-Controller) architecture and is based on Wesley Werner&rsquo;s <a href=(https://github.com/wesleywerner/mvc-game-design)>repository</a>. I highly recommend checking out his repository for better understanding.</p><ul><li>Important Files<ul><li><code>main.py</code>: Entry point for the game application</li><li><code>src</code> : Containing all of the python source code<ul><li><code>logger.py</code>: Defines the logger of the game</li><li><code>event.py</code>: Defines different type of event in the game environment</li><li><code>model.py</code>: Defines the Game Engine of game</li><li><code>view.py</code>: Defines the Visual of the game</li><li><code>maze_game</code>: Contains the logic and maze generation code.</li><li><code>maze_visualization</code>: Contains helper function for game visuals</li></ul></li><li><code>test</code>: Contains the test written for the game</li></ul></li></ul><h3 id=maze-generation>Maze Generation<a hidden class=anchor aria-hidden=true href=#maze-generation>#</a></h3><p>I used the <a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm#Randomized_Prim's_algorithm">Randomized Prim&rsquo;s algorithm</a> for generating the maze, which is a popular choice for maze generation. I followed Orestis Zekai&rsquo;s article on maze generation using Python, which was helpful for the basic setup. However, I had some difficulty following the final parts of the <a href=https://medium.com/swlh/fun-with-python-1-maze-generator-931639b4fb7e>article</a>, so I implemented my own version. You can find the final version of my implementation in this <a href=https://github.com/Avashist1998/maze_game/blob/develop/src/maze_game/maze_generation.py>file</a> on Github.</p><h4 id=maze-board-value-enum>Maze Board Value Enum<a hidden class=anchor aria-hidden=true href=#maze-board-value-enum>#</a></h4><p>The <code>MazeGameObject</code> enum improves the readability of the code and creates a layer of abstraction between the values on the game board and the maze generation code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MazeGameObject</span>(Enum):
</span></span><span style=display:flex><span>    PATH <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    WALL <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    GOAL <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    EMPTY <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    PLAYER_TILE <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>    VISITED_TILE <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><h3 id=maze-generation-code-breakdown>Maze Generation Code breakdown<a hidden class=anchor aria-hidden=true href=#maze-generation-code-breakdown>#</a></h3><ul><li>Initialize the maze with Empty object values (Exactly same as Zekai)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>init_maze</span>(height, width):
</span></span><span style=display:flex><span>    maze <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(height):
</span></span><span style=display:flex><span>        maze_row <span style=color:#f92672>=</span> [MazeGameObject<span style=color:#f92672>.</span>EMPTY<span style=color:#f92672>.</span>value <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(width)]
</span></span><span style=display:flex><span>        maze<span style=color:#f92672>.</span>append(maze_row)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> maze
</span></span></code></pre></div><ul><li>Pick a start position by randomly selecting a location in the maze that does not lie on the edge. (Exactly same as Zekai)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> random <span style=color:#f92672>import</span> random
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_start_pos</span>(row, col):
</span></span><span style=display:flex><span>    start_row, start_col <span style=color:#f92672>=</span> int(random() <span style=color:#f92672>*</span> (row<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>))<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, int(random() <span style=color:#f92672>*</span> (col<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>))<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> start_row, start_col
</span></span></code></pre></div><ul><li>Function fills the empty cells with wall value (Exactly same as Zekai)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fill_walls</span>(maze)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, _ <span style=color:#f92672>in</span> enumerate(maze):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(len(maze[<span style=color:#ae81ff>0</span>])):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> maze[i][j] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>EMPTY<span style=color:#f92672>.</span>value:
</span></span><span style=display:flex><span>                maze[i][j] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value
</span></span></code></pre></div><ul><li>To determine the number of paths surrounding a given cell in the maze, we examine the adjacent cells using <code>if</code> statements. If the cells are within the grid&rsquo;s boundaries and have the same value as the path, the <code>s_cell_count</code> is incremented.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_surrounding_cell_count</span>(cell, maze):
</span></span><span style=display:flex><span>    s_cell_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cell[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> 
</span></span><span style=display:flex><span>        maze[cell[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][cell[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>==</span>  MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value):
</span></span><span style=display:flex><span>        s_cell_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cell[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&lt;</span> len(maze) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> 
</span></span><span style=display:flex><span>        maze[cell[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][cell[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>==</span>  MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value):
</span></span><span style=display:flex><span>        s_cell_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cell[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> 
</span></span><span style=display:flex><span>        maze[cell[<span style=color:#ae81ff>0</span>]][cell[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span>  MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value):
</span></span><span style=display:flex><span>        s_cell_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (cell[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&lt;</span> len(maze[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>and</span> 
</span></span><span style=display:flex><span>        maze[cell[<span style=color:#ae81ff>0</span>]][cell[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span>  MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value):
</span></span><span style=display:flex><span>        s_cell_count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> s_cell_count
</span></span></code></pre></div><ul><li>To create entry and exit points for the maze after it&rsquo;s generated, we break the top and bottom walls of the maze into paths that are adjacent to existing paths. This creates a long and winding path that leads from the entrance to the exit of the maze. This step is important because it ensures that there is a clear path from the entrance to the exit, and that the maze is solvable.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_entry_exit</span>(maze):
</span></span><span style=display:flex><span>    row, col <span style=color:#f92672>=</span> len(maze), len(maze[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    start_point, exit_point <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>), (row <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, col <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Set entrance and exit</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(col):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> maze[<span style=color:#ae81ff>1</span>][i] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value:
</span></span><span style=display:flex><span>            maze[<span style=color:#ae81ff>0</span>][i] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>PLAYER_TILE<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>            start_point <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>, i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(col <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> maze[row <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>][i] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value:
</span></span><span style=display:flex><span>            maze[row <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][i] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>GOAL<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>            exit_point <span style=color:#f92672>=</span> (row <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, i)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> start_point, exit_point, maze
</span></span></code></pre></div><ul><li><p>Generation the maze</p><ul><li><p>The first step in generating the maze is to initialize the board using the <code>init_maze</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    maze <span style=color:#f92672>=</span> init_maze(n_row, n_col)
</span></span></code></pre></div></li><li><p>We need to determine the starting position of the maze, which we achieve using the get_start_pos function. This function ensures that the starting position is always a path cell and returns its coordinates. We then set the start_pos variable to these coordinates.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    start_pos <span style=color:#f92672>=</span> get_start_pos(maze)
</span></span><span style=display:flex><span>    maze[start_pos[<span style=color:#ae81ff>0</span>]][start_pos[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value
</span></span></code></pre></div></li><li><p>We assign the surrounding cells to the <code>start_pos</code> to the value of a <code>WALL</code>. Then we add the defined walls the our queue, in my case a set named <code>wall_list</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    maze[start_pos[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][start_pos[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>    maze[start_pos[<span style=color:#ae81ff>0</span>]][start_pos[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>    maze[start_pos[<span style=color:#ae81ff>0</span>]][start_pos[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>    maze[start_pos[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][start_pos[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    wall_list <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    wall_list<span style=color:#f92672>.</span>add((start_pos[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, start_pos[<span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>    wall_list<span style=color:#f92672>.</span>add((start_pos[<span style=color:#ae81ff>0</span>], start_pos[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    wall_list<span style=color:#f92672>.</span>add((start_pos[<span style=color:#ae81ff>0</span>], start_pos[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    wall_list<span style=color:#f92672>.</span>add((start_pos[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, start_pos[<span style=color:#ae81ff>1</span>]))
</span></span></code></pre></div></li><li><p>After the initialization steps, the maze generation algorithm repeats the following steps until all the walls in the maze have been processed:</p><ul><li>Pick a random wall from the <code>wall_list</code>.</li><li>Count the number of surrounding cells of the wall that are paths using the <code>get_surrounding_cell_count</code> function.</li><li>If the count is greater than 1, remove the wall from the <code>wall_list</code> since it has been processed.</li><li>If the count is 1, we process the wall and remove the wall from the <code>wall_list</code>.</li><li>We continue this process until the <code>wall_list</code> is empty.</li></ul></li><li><p>After all the cells are processed, we fill the remaining cells with walls using the fill_walls function.</p></li><li><p>Finally, we create an entry and exit in the maze using the <code>create_entry_exit</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> random <span style=color:#f92672>import</span> choices
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> wall_list:
</span></span><span style=display:flex><span>    rand_wall <span style=color:#f92672>=</span> choices(list(wall_list), k<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    s_cell_count <span style=color:#f92672>=</span> get_surrounding_cell_count(rand_wall, maze)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> s_cell_count <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>        <span style=color:#75715e>### Wall Processing block</span>
</span></span><span style=display:flex><span>    wall_list<span style=color:#f92672>.</span>remove(rand_wall)
</span></span><span style=display:flex><span>fill_walls(maze)
</span></span><span style=display:flex><span>entry_point, exit_point, maze <span style=color:#f92672>=</span> create_entry_exit(maze)
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> entry_point, exit_point, maze
</span></span></code></pre></div></li><li><p>The &ldquo;Row case&rdquo; and &ldquo;Col case&rdquo; refer to the two possibilities for which direction the wall being processed is oriented: either horizontally (a &ldquo;row&rdquo;) or vertically (a &ldquo;column&rdquo;).</p><ul><li>For each of these cases, there are two sub-cases, based on whether the wall is at the edge of the grid or not.</li><li>If the wall being processed is not at the edge of the grid, the code checks the cells on either side of the wall to see if one of them is a path and the other empty (i.e. possible connected). If so, the wall is removed from the wall list, meaning it is no longer available to be broken down.</li><li>If the wall being processed is at the edge of the grid, the code only checks the cells on the side that is not at the edge. This is because the cells on the other side are already known to be walls, since they lie outside the bounds of the grid.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-markdown data-lang=markdown><span style=display:flex><span>Row Cases:
</span></span><span style=display:flex><span>    Case 1:         Case 2:
</span></span><span style=display:flex><span>        Path               Empty
</span></span><span style=display:flex><span>        |                  |
</span></span><span style=display:flex><span>        Wall               Wall
</span></span><span style=display:flex><span>        |                  |
</span></span><span style=display:flex><span>        Empty              Path   
</span></span><span style=display:flex><span>Col Cases:
</span></span><span style=display:flex><span>    Case 1: Path - Wall - Empty
</span></span><span style=display:flex><span>    Case 2: Empty - Wall - Path
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>if</span> (rand_wall[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> rand_wall[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> n_row):
</span></span><span style=display:flex><span>    <span style=color:#75715e># row case</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (maze[rand_wall[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][rand_wall[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value 
</span></span><span style=display:flex><span>        <span style=color:#f92672>and</span> maze[rand_wall[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][rand_wall[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value):
</span></span><span style=display:flex><span>        <span style=color:#75715e># Case 2</span>
</span></span><span style=display:flex><span>        maze[rand_wall[<span style=color:#ae81ff>0</span>]][rand_wall[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        maze[rand_wall[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>][rand_wall[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>        maze[rand_wall[<span style=color:#ae81ff>0</span>]][rand_wall[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>        maze[rand_wall[<span style=color:#ae81ff>0</span>]][rand_wall[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        wall_list<span style=color:#f92672>.</span>add((rand_wall[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, rand_wall[<span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>        wall_list<span style=color:#f92672>.</span>add((rand_wall[<span style=color:#ae81ff>0</span>], rand_wall[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        wall_list<span style=color:#f92672>.</span>add((rand_wall[<span style=color:#ae81ff>0</span>], rand_wall[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (maze[rand_wall[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][rand_wall[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value 
</span></span><span style=display:flex><span>        <span style=color:#f92672>and</span> maze[rand_wall[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>][rand_wall[<span style=color:#ae81ff>1</span>]] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>PATH<span style=color:#f92672>.</span>value):
</span></span><span style=display:flex><span>        <span style=color:#75715e># Case 1</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># Similar logic as case 2 block</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (rand_wall[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>and</span> rand_wall[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;</span> n_col):
</span></span><span style=display:flex><span>    <span style=color:#75715e>### similar logic as above row cases</span>
</span></span></code></pre></div></li></ul></li></ul><h3 id=maze-visualization>Maze Visualization<a hidden class=anchor aria-hidden=true href=#maze-visualization>#</a></h3><p>Visualizing the maze requires two main functions, <code>draw_maze</code> and <code>draw_tile</code> which are defined <a href=https://github.com/Avashist1998/maze_game/blob/07cb8f2943dea72f322c4f02b75301312be9b7a6/src/maze_visualization/maze_game_visualization.py#L186-L234>here</a>. The function communicates using two data classes called <code>Tile</code> and <code>ScreenSize</code>. This approach makes the visualization independent of the value of the tile and treats each tile equally. In other words, the function doesn&rsquo;t need to know what the tile represents in terms of the maze structure, it only needs to know the dimensions of the tile and the screen size to properly display it on the screen. This separation of concerns makes the code easier to maintain and modify in the future, as changes to the tile value won&rsquo;t affect the visualization code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> dataclasses <span style=color:#f92672>import</span> dataclass
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Tile</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Maze tile data object definition.&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    tile_color: Color
</span></span><span style=display:flex><span>    border_color: Color
</span></span><span style=display:flex><span>    tile_space: ScreenSize
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@dataclass</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ScreenSize</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;Screen size dataclass&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    width: int
</span></span><span style=display:flex><span>    height: int
</span></span><span style=display:flex><span>    top_left_x: int
</span></span><span style=display:flex><span>    top_left_y: int
</span></span></code></pre></div><p>In the <code>draw_maze</code> function, the first step is to calculate the total dimensions and define the screen size of the maze in pixels. The maze will occupy all of the space on the screen except for 50 pixels on the left and right sides, and 75 pixels on the top and 25 pixels on the bottom. Once we have the maze size in pixels, we need to compute the size of individual tiles using integer division.</p><p>Next, we iterate through the grid and set the appropriate tile color based on the grid cell value. We calculate the tile&rsquo;s top-left coordinates by multiplying the index with the tile size and adding the maze board&rsquo;s top-left coordinates. Then, we call the <code>draw_tile</code> function to render the tile on the screen.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>board <span style=color:#f92672>=</span> maze<span style=color:#f92672>.</span>get_board() <span style=color:#75715e># maze generated previously</span>
</span></span><span style=display:flex><span>row, col <span style=color:#f92672>=</span> len(board), len(board[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>maze_board_top, maze_board_left <span style=color:#f92672>=</span> <span style=color:#ae81ff>75</span>, <span style=color:#ae81ff>50</span>
</span></span><span style=display:flex><span>maze_screen_width <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>screen_width <span style=color:#f92672>-</span> <span style=color:#ae81ff>100</span> 
</span></span><span style=display:flex><span>maze_screen_height <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>screen_height <span style=color:#f92672>-</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>tile_width, tile_height <span style=color:#f92672>=</span> maze_screen_width <span style=color:#f92672>//</span> col, maze_screen_height <span style=color:#f92672>//</span> row
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(row):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(col):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> board[i][j] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>WALL<span style=color:#f92672>.</span>value:
</span></span><span style=display:flex><span>            tile_color <span style=color:#f92672>=</span> WALL_COLOR
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> board[i][j] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>GOAL<span style=color:#f92672>.</span>value:
</span></span><span style=display:flex><span>            tile_color <span style=color:#f92672>=</span> GOAL_COLOR
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> board[i][j] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>VISITED_TILE<span style=color:#f92672>.</span>value:
</span></span><span style=display:flex><span>            tile_color <span style=color:#f92672>=</span> VISITED_COLOR
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>elif</span> board[i][j] <span style=color:#f92672>==</span> MazeGameObject<span style=color:#f92672>.</span>PLAYER_TILE<span style=color:#f92672>.</span>value:
</span></span><span style=display:flex><span>            tile_color <span style=color:#f92672>=</span> PLAYER_COLOR
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            tile_color <span style=color:#f92672>=</span> PATH_COLOR
</span></span><span style=display:flex><span>        tile_space <span style=color:#f92672>=</span> ScreenSize(tile_width, tile_height,
</span></span><span style=display:flex><span>                                maze_board_left <span style=color:#f92672>+</span> j <span style=color:#f92672>*</span> tile_width,
</span></span><span style=display:flex><span>                                maze_board_top <span style=color:#f92672>+</span> i <span style=color:#f92672>*</span> tile_height)
</span></span><span style=display:flex><span>        tile <span style=color:#f92672>=</span> Tile(tile_color, TILE_BORDER_COLOR, tile_space)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>draw_tile(tile)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>draw_tile</span>(self, tile):
</span></span><span style=display:flex><span>    boarder_thickness <span style=color:#f92672>=</span> int(tile<span style=color:#f92672>.</span>tile_space<span style=color:#f92672>.</span>width <span style=color:#f92672>*</span> <span style=color:#ae81ff>0.1</span>) 
</span></span><span style=display:flex><span>    pygame<span style=color:#f92672>.</span>draw<span style=color:#f92672>.</span>rect(
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>screen, tile<span style=color:#f92672>.</span>tile_color,
</span></span><span style=display:flex><span>        pygame<span style=color:#f92672>.</span>Rect(tile<span style=color:#f92672>.</span>tile_space<span style=color:#f92672>.</span>top_left_x, tile<span style=color:#f92672>.</span>tile_space<span style=color:#f92672>.</span>top_left_y,
</span></span><span style=display:flex><span>                    tile<span style=color:#f92672>.</span>tile_space<span style=color:#f92672>.</span>width, tile<span style=color:#f92672>.</span>tile_space<span style=color:#f92672>.</span>height), <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> boarder_thickness <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        pygame<span style=color:#f92672>.</span>draw<span style=color:#f92672>.</span>rect(
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>screen, tile<span style=color:#f92672>.</span>border_color,
</span></span><span style=display:flex><span>            pygame<span style=color:#f92672>.</span>Rect(tile<span style=color:#f92672>.</span>tile_space<span style=color:#f92672>.</span>top_left_x,
</span></span><span style=display:flex><span>                        tile<span style=color:#f92672>.</span>tile_space<span style=color:#f92672>.</span>top_left_y, tile<span style=color:#f92672>.</span>tile_space<span style=color:#f92672>.</span>width,
</span></span><span style=display:flex><span>                        tile<span style=color:#f92672>.</span>tile_space<span style=color:#f92672>.</span>height), boarder_thickness)
</span></span></code></pre></div><h3 id=maze-animation>Maze Animation<a hidden class=anchor aria-hidden=true href=#maze-animation>#</a></h3><p><img loading=lazy src=https://raw.githubusercontent.com/Avashist1998/Avashist1998.github.io/main/static/images/maze_solving.gif alt></p><h3 id=final-thoughts>Final Thoughts<a hidden class=anchor aria-hidden=true href=#final-thoughts>#</a></h3><p>This project to build a maze game using pygame was a valuable experience for me, and I highly recommend it as a way to learn pygame and prototype game ideas. Pygame provides a great environment for individuals to develop simple and small games, and the process can be very enjoyable. I hope you found my explanation of the project informative and enjoyable.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://avashist1998.github.io/tags/pygame/>pygame</a></li><li><a href=https://avashist1998.github.io/tags/python/>python</a></li><li><a href=https://avashist1998.github.io/tags/game/>game</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://avashist1998.github.io>Abhay Vashist</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>